<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0">
  <channel>
    <title>itemis Blog AMP</title>
    <link>https://blogs.itemis.com</link>
    <description>Der Blog der itemis AG: Softwareentwicklung, Usability Engineering, Xtext, Scrum und vieles mehr</description>
    <language>en-us</language>
    <pubDate>Fri, 30 Jun 2017 07:25:29 GMT</pubDate>
    <dc:date>2017-06-30T07:25:29Z</dc:date>
    <dc:language>en-us</dc:language>
    <item>
      <title>Feature of the month: Structuring your statecharts with subdiagrams</title>
      <link>https://blogs.itemis.com/en/feature-of-the-month-structuring-your-statecharts-with-subdiagrams</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/feature-of-the-month-structuring-your-statecharts-with-subdiagrams" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/Stockmaterial_allgemein/Fotolia_129028959_M.jpg?t=1499164433530" alt="Feature of the month: Structuring your statecharts with subdiagrams" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Composite states are a good means to bring order and structure to a statechart. However, as a statechart grows, it may easily become too big to give a comprehensive overview of the whole model anymore. Let's have a look at how s&lt;span&gt;ubdiagrams can help you out. &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Composite states are a good means to bring order and structure to a statechart. However, as a statechart grows, it may easily become too big to give a comprehensive overview of the whole model anymore. Let's have a look at how s&lt;span&gt;ubdiagrams can help you out. &lt;/span&gt;Imagine what would happen if a statechart grew by a few hundred additional states: even if structured into (possibly nested) composite states, the clearness decreases and the diagram would simply be too big to be printed or to give a clear overview on a screen. There is a simple solution, however: create subdiagrams! A subdiagram is a composite state “folded away” into an (almost) normal-looking leaf state.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You can create a subdiagram by selecting the state you want to expand and select “Create Subdiagram” in the context menu. After doing this you see a little decorator image on the state. Clicking on it opens the subdiagram showing an empty canvas of the subdiagram editor.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Feature%20of%20the%20month%202017-06/createSubdiagramCreateRegion.png?t=1499164433530&amp;amp;width=724&amp;amp;height=305&amp;amp;name=createSubdiagramCreateRegion.png" alt="createSubdiagramCreateRegion.png" width="724" height="305"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You need a region first and create your substatechart within this region. If you want to define variables and events you need to do this in the definition section of the parent statechart. The subdiagram does not have its own definition section.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Feature%20of%20the%20month%202017-06/createSubdiagramDefineEvents.png?t=1499164433530&amp;amp;width=724&amp;amp;height=308&amp;amp;name=createSubdiagramDefineEvents.png" alt="createSubdiagramDefineEvents.png" width="724" height="308"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;If you already have a large state machine you want to restructure it's best to use the “Extract Subdiagram” refactoring. It can be applied on composite states and orthogonal states. Simply select the composite state and then “Refactor” - “Extract subdiagram”. When refactoring is executed, all contained regions are extracted into regions within a separate diagram. This refactoring adds entry and exit nodes in the subdiagram as needed. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The following diagram has two composite states with a couple of substates:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Feature%20of%20the%20month%202017-06/CompositeStatemachine.png?t=1499164433530&amp;amp;width=661&amp;amp;height=466&amp;amp;name=CompositeStatemachine.png" alt="CompositeStatemachine.png" width="661" height="466" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now the composite state no longer clutters the diagram with all its internal details, but instead it appears almost like a normal state. The only difference is a small decorator in the lower-right corner of the state, indicating the existence of a subdiagram. When you hover over this decorator with your mouse you’ll see a small preview of the subdiagram.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Feature%20of%20the%20month%202017-06/hoverSubdiagramm.png?t=1499164433530&amp;amp;width=657&amp;amp;height=459&amp;amp;name=hoverSubdiagramm.png" alt="hoverSubdiagramm.png" width="657" height="459" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;A click on the decorator opens the subdiagram in a separate editor tab. The breadcrumb view at the top allows easy navigation throughout hierarchy levels.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Simulation of statecharts with subdiagrams work like simulations without subdiagrams. Refactoring does not affect the execution sequence. Start the simulation by selecting “Run as”- “Statechart simulation”. When the simulation reaches the subdiagram you can follow it by opening it in the editor or watch the hover image.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Feature%20of%20the%20month%202017-06/subdiagramsSimulation.png?t=1499164433530&amp;amp;width=724&amp;amp;height=467&amp;amp;name=subdiagramsSimulation.png" alt="subdiagramsSimulation.png" width="724" height="467"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;If you want to invert the “Extract subdiagram” refactoring simply use “Inline subdiagram” refactoring. Please note that entry and exit points that were introduced in the subdiagram will stay in the composite state as well. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Subdiagrams do not have any impact on code generation. You can generate code from statecharts with subdiagrams like you generate without subdiagrams. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;If you work with large statecharts, try out subdiagrams and declutter your models. You can find additional information &lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/user-guide/#using-subdiagrams"&gt;in our user documentation&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Ffeature-of-the-month-structuring-your-statecharts-with-subdiagrams&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <category>english</category>
      <pubDate>Tue, 27 Jun 2017 07:05:00 GMT</pubDate>
      <author>svenja.wendler@itemis.de (Svenja Wendler)</author>
      <guid>https://blogs.itemis.com/en/feature-of-the-month-structuring-your-statecharts-with-subdiagrams</guid>
      <dc:date>2017-06-27T07:05:00Z</dc:date>
    </item>
    <item>
      <title>Style your statecharts with YAKINDU Statechart Tools</title>
      <link>https://blogs.itemis.com/en/style-your-statecharts-with-yakindu-statechart-tools</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/style-your-statecharts-with-yakindu-statechart-tools" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/hello-world-statecharts.jpg?t=1499164433530" alt="Style your statecharts with YAKINDU Statechart Tools" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;Did you know you can style your statecharts with YAKINDU Statechart Tools? For example, it might be useful to highlight certain states by color – especially when dealing with large state machines. You can group states by color and point out semantics by coloring states. Or maybe you want to mark statecharts that need to be reworked by color. Therefore it's our "feature of the month".&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="background-color: transparent;"&gt;Did you know you can style your statecharts with YAKINDU Statechart Tools? For example, it might be useful to highlight certain states by color – especially when dealing with large state machines. You can group states by color and point out semantics by coloring states. Or maybe you want to mark statecharts that need to be reworked by color. Therefore it's our "feature of the month".&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Look at the image below: Statecharts usually look like this unstyled traffic lights statechart. But it is also possible to change colors and fonts of transitions, states, and regions.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/YAKINDU-Statechart-Tools-changing-colors.png?t=1499164433530&amp;amp;width=620&amp;amp;name=YAKINDU-Statechart-Tools-changing-colors.png" alt="YAKINDU-Statechart-Tools-changing-colors.png" width="620" style="display: block; margin-left: auto; margin-right: auto; width: 620px;" title="YAKINDU-Statechart-Tools-changing-colors.png"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;&lt;br&gt;YAKINDU Statechart Tools&lt;/a&gt; offers two different ways of changing the colors of regions and states:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;changing the default design&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;changing only specific states&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;If you want to change the default coloring of statecharts open the preference page (Window → Preferences → YAKINDU SCT → Diagram Appearance). Here you can change the colors of regions, states, and their borderlines. Please note that changed default colors will apply to new objects only. States and regions you have created so far will remain unchanged.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/YAKINDU-Statechart-Tools-Change-design-individually.png?t=1499164433530&amp;amp;width=635&amp;amp;height=555&amp;amp;name=YAKINDU-Statechart-Tools-Change-design-individually.png" alt="YAKINDU-Statechart-Tools-Change-design-individually.png" width="635" height="555" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;The other way is to change the design of particular states individually. To do this, select the state (or multiple states) you want to colorize. In the context menu, select “Show Properties View”. There are two tabs, “Diagram” and “Appearance”. On the “Appearance” tab, you can change background color, line color, and the font of a single state.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/YAKINDU-Statechart-Tools-copy-style.png?t=1499164433530&amp;amp;width=724&amp;amp;height=379&amp;amp;name=YAKINDU-Statechart-Tools-copy-style.png" alt="YAKINDU-Statechart-Tools-copy-style.png" width="724" height="379" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;Once you colorized one state, you can copy this style by selecting the colorized state first and the target states afterwards. Then click at the “Apply the applicable appearance properties of the first selected shape to the other selected shapes” symbol, which is highlighted in the image below.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/YAKINDU-Statechart-Tools-colorize-transitions.png?t=1499164433530&amp;amp;width=556&amp;amp;height=56&amp;amp;name=YAKINDU-Statechart-Tools-colorize-transitions.png" alt="YAKINDU-Statechart-Tools-colorize-transitions.png" width="556" height="56" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;You can also colorize transitions. To colorize a transition or multiple transition select it and select the color in the properties view. &lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Transition routing &lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Tools comes with two different routing strategies for transitions: oblique and rectilinear routing. For a better understanding see the screenshot below. As you can see, rectilinear routing means that all transition segments are either horizontal or vertical, while oblique routing allows to have diagonal lines.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/YAKINDU-Statechart-Tools-apply-styling.png?t=1499164433530&amp;amp;width=671&amp;amp;height=373&amp;amp;name=YAKINDU-Statechart-Tools-apply-styling.png" alt="YAKINDU-Statechart-Tools-apply-styling.png" width="671" height="373" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;Again, this styling can be applied either individually on each transition, or globally for all new transitions created anywhere in the statechart by using the preference page (see screenshot above). &amp;nbsp;Tree routing is no option in YAKINDU Statechart Tools.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Smooth Transitions&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The properties view tab “Appearance” makes it possible to “smooth” transitions, which means that they get curved. There are four smoothness levels: none (default), less, normal, and more. The image visualizes the differences between none, less and more. The normal and less are looking nearly similar.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/YAKINDU-Statechart-Tools-curvy-transitions.png?t=1499164433530&amp;amp;width=724&amp;amp;height=442&amp;amp;name=YAKINDU-Statechart-Tools-curvy-transitions.png" alt="YAKINDU-Statechart-Tools-curvy-transitions.png" width="724" height="442" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Align states horizontally and vertically&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You can align states to get a well-ordered arrangement. States can be aligned either horizontally (align top, align middle, align bottom) or vertically (align left, align center, align right). The reference defining where to align is the state you selected last. The image shows the same alignment (align left) with a different order of selection (see the numbers).&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Decluttering statecharts by refactoring&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/user-guide/#editing-statecharts"&gt;To cleanup your statechart you can also edit and refactor it&lt;/a&gt;. You can split off parts of the statechart into multiple regions or use sub-statecharts and composite states.&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Styling can help you to enhance the appearance of your statecharts. But be careful: If you use too many colors the statechart will look messy. The understandability might decrease instead of raise. My recommendation is to not use more than three different colors in small statecharts of, say, upto 20 states. If your statechart is larger, do not use more than five colors. Choose colors that differentiate clearly to emphasize certain parts of your statechart. So – try it yourself and happy styling ;)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fstyle-your-statecharts-with-yakindu-statechart-tools&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <category>english</category>
      <pubDate>Tue, 30 May 2017 13:01:17 GMT</pubDate>
      <author>svenja.wendler@itemis.de (Svenja Wendler)</author>
      <guid>https://blogs.itemis.com/en/style-your-statecharts-with-yakindu-statechart-tools</guid>
      <dc:date>2017-05-30T13:01:17Z</dc:date>
    </item>
    <item>
      <title>How to program your Raspberry Pi with Statechart Tools in 5 Minutes</title>
      <link>https://blogs.itemis.com/en/how-to-program-your-raspberry-pi-with-statechart-tools-in-5-minutes</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/how-to-program-your-raspberry-pi-with-statechart-tools-in-5-minutes" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/Raspberry-Pi-preview.jpg?t=1499164433530" alt="How to program your Raspberry Pi with Statechart Tools in 5 Minutes" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Following our prior &lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/examples/"&gt;&lt;span&gt;examples&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;&amp;nbsp;describing the usage of YAKINDU Statechart Tools on embedded platforms, this blog article aims to walk you through the process of using Statechart Tools to bring your Raspberry Pi to life.&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Following our prior &lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/examples/"&gt;&lt;span&gt;examples&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;&amp;nbsp;describing the usage of YAKINDU Statechart Tools on embedded platforms, this blog article aims to walk you through the process of using Statechart Tools to bring your Raspberry Pi to life.&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Raspberry-Pi-preview.jpg?t=1499164433530&amp;amp;width=724&amp;amp;name=Raspberry-Pi-preview.jpg" alt="How-to-program-your-Raspberry-Pi-with-statechart-tools.jpg" width="724" title="How-to-program-your-Raspberry-Pi-with-statechart-tools.jpg" style="width: 724px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Because the Raspberry Pi differs from smaller platforms and actually runs Linux itself, there are multiple ways to make this work. It should actually be possible to just plug your Pi into a monitor and execute &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt;&amp;nbsp;(SCT) on it. Because its processing power and especially the Java support is a bit lacking at times and I don’t want to connect a keyboard, a mouse and a screen to it, I will show you a remote way to do it.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;What you’ll need:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;A Raspberry Pi equipped with…&lt;/span&gt;&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Network access&lt;/span&gt;&lt;/li&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;SSH configured&lt;/span&gt;&lt;/li&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;A RGB LED&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;A host pc:&lt;/span&gt;&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;I am working on Linux, using cross compilers and ssh is a lot easier there&lt;/span&gt;&lt;/li&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;An installation of YAKINDU Statechart Tools&lt;/span&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Knowledge:&lt;/span&gt;&lt;/li&gt; 
 &lt;ul&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Basic Linux&lt;/span&gt;&lt;/li&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Basic C&lt;/span&gt;&lt;/li&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;You have worked with statechart tools before (see our &lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/tutorials/#oss_five-minutes-tutorial"&gt;tutorial&lt;/a&gt;&amp;nbsp;and download YAKINDU Statechart Tools if you haven't yet&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;)&amp;nbsp;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;&lt;/span&gt;&lt;/li&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;You have used ssh before&lt;/span&gt;&lt;/li&gt; 
  &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;All in all, I would say this tutorial is intermediate level&lt;/span&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/li&gt; 
 &lt;/ul&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;What we will do:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Install a cross compiler for the Pi on Linux&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Install the TCF plugin into Statechart Tools and on the Pi&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Set up cross compiling in Statechart Tools&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Create a small statechart&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Use the GPIOs…&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;...and make a RGB LED switch colors!&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Installing the cross compiler&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Cross compiling means to compile code on a host with an architecture that differs from the target architecture. In our case, the host will be a regular PC with x86_64 architecture, whereas the Raspberry Pi’s heart is an ARM processor. The different generations of the Raspberry use different processors, but luckily that’s not important for us.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;For the record: I’m running Ubuntu 16.10. For other distributions, the name of the package manager and the names of packages can vary slightly, but normally that’s easy to figure out.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;We need to install two packages on the host PC, the first one should be installed already:&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;sudo apt-get install build-essential g++-arm-linux-gnueabihf&lt;/pre&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;That’s all you need for cross compiling.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Install TCF&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;TCF seems to be an abbreviation for pretty much everything according to Wikipedia, but I am talking about Eclipse TCF, the &lt;/span&gt;&lt;a href="http://www.eclipse.org/tcf/"&gt;&lt;span style="font-weight: 400;"&gt;Target Communication Framework&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;It provides a very simple solution to automatically discover targets on the network, communicate with them, deploy binaries to them, inspect their file system, and much more. Also you can debug your applications out of the box.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;To do all that, you’ll need to login on the Pi once, so now is the only time you will use ssh in this blog article.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;If you cannot ssh into your Pi, just grab another screen and a keyboard.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;For me, the IP of the Pi is 192.168.3.85, and nobody cared to change the standard user’s (pi) password (raspberry), so:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Raspberry-Pi-IP_01.png?t=1499164433530&amp;amp;width=724&amp;amp;name=Raspberry-Pi-IP_01.png" alt="Raspberry-Pi-and-YAKINDU-Statechart-Tools.png" width="724" style="width: 724px; display: block; margin-left: auto; margin-right: auto;" title="Raspberry-Pi-and-YAKINDU-Statechart-Tools.png"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;Great, it works!&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;If you haven’t already, you can install git now while you’re at it:&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;sudo apt-get install git&lt;/pre&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;We’ll need it to clone the sources of the TCF agent that runs on the Pi and communicates with Eclipse on our host. If you want to know you can find &lt;/span&gt;&lt;a href="http://wiki.eclipse.org/TCF/Raspberry_Pi"&gt;&lt;span style="font-weight: 400;"&gt;a short&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;&amp;nbsp;article about installing TCF on the Pi on wiki.eclipse.org&lt;/span&gt;&lt;/a&gt;&lt;span style="background-color: transparent;"&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Just follow the sections “Building the TCF Agent” and “Installing the Agent for auto-start”, the latter for convenience.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You can now type exit into the ssh terminal and say bye bye.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now launch YAKINDU Statechart Tools on your host PC.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Go to Help -&amp;gt; Install new Software, click on [Add…], and paste TCF’s update site into the field location.&lt;br&gt;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;You can find it on &lt;/span&gt;&lt;a href="http://www.eclipse.org/tcf/downloads.php"&gt;&lt;span&gt;http://www.eclipse.org/tcf/downloads.php&lt;/span&gt;&lt;/a&gt;.&lt;br&gt;At the time of writing, the correct update site would be:&lt;br&gt;http://download.eclipse.org/tools/tcf/builds/neon/nightly&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;It should look like this:&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/TCF-Update-Side-YAKINDU-Statechart-Tools_02.png?t=1499164433530&amp;amp;width=558&amp;amp;name=TCF-Update-Side-YAKINDU-Statechart-Tools_02.png" alt="TCF-Update-Side-YAKINDU-Statechart-Tools-and-Raspberry-Pi.png" width="558" style="display: block; margin-left: auto; margin-right: auto; width: 558px;" title="TCF-Update-Side-YAKINDU-Statechart-Tools-and-Raspberry-Pi.png"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Just select [OK]. After a short time of saying &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Pending… &lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;the install wizard should allow you to install the Target Communication Framework and the Target Explorer.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/install-target-communication-framework-and-target-explorer_03.png?t=1499164433530&amp;amp;width=724&amp;amp;name=install-target-communication-framework-and-target-explorer_03.png" alt="install-target-communication-framework-and-target-explorer-for-Raspberry-Pi-and-YAKINDU-Statechart-Tools.png" width="724" title="install-target-communication-framework-and-target-explorer-for-Raspberry-Pi-and-YAKINDU-Statechart-Tools.png" style="width: 724px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The installation will tell you that it has some issues because dependencies cannot be fulfilled and it will calculate a modified installation, which we’ll accept. Click on [Next &amp;gt; ] and just accept everything the wizard tells you to do.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The actual installation is a good time to grab another coffee. When it is done, you will need to accept a certificate and then restart Statechart Tools, that’s it.&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style="font-weight: 400;"&gt;Explore TCF&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;After Statechart Tools restarted, you can now go to Window -&amp;gt; Perspective -&amp;gt; Open Perspective -&amp;gt; Other… . Select Target Explorer.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/target-explorer_04.png?t=1499164433530&amp;amp;width=336&amp;amp;name=target-explorer_04.png" alt="target-explorer-Raspberry-Pi-Statechart-Tools.png" width="336" style="display: block; margin-left: auto; margin-right: auto; width: 336px;" title="target-explorer-Raspberry-Pi-Statechart-Tools.png"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Click [OK].&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now you have got a new tab next to Project Explorer named “System Management”. In there, you will find “Neighborhood”, which lists all running TCF agents on your network.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/TCF-Neighborhood_05.png?t=1499164433530&amp;amp;width=379&amp;amp;name=TCF-Neighborhood_05.png" alt="TCF-Neighborhood-Raspberry-Pi-YAKINDU-Statechart-Tools.png" width="379" style="display: block; margin-left: auto; margin-right: auto; width: 379px;" title="TCF-Neighborhood-Raspberry-Pi-YAKINDU-Statechart-Tools.png"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;There is our little Pi! Right-click, select Connect, and confirm everything as-is. It should now show up under Connections.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;The project&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;As usual, you can directly check out the project from Yakindu’s example repository using the built-in example wizard. Go to New -&amp;gt; Example -&amp;gt; Yakindu Statechart Examples to use it. The name is “Raspberry Pi Hello World”.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Another possibility is to visit our &lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/examples/"&gt;examples page&lt;/a&gt;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;. You can explore examples and even use a drag-and-drop button to directly drop examples into your running Statechart Tool.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;There are four things I want to talk about:&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style="font-weight: 400;"&gt;Build configurations&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Normally, when you set up a C project with Eclipse, two build configurations will be generated: Debug and Release. This mechanism of build configurations gives you a possibility to build the code with varying compilers, library settings, symbols – whatever you need. Here, I added a build configuration named “RPi_Cross”, which has the cross compiler set up that we installed in the first step. If you do not use Ubuntu, you might need to change something here, especially if you are working on a Windows machine.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Right click the project, select “Properties” all the way down in the context menu, and navigate to C/C++ Build -&amp;gt; Settings. You can select the configuration in the top and edit the values below.&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style="font-weight: 400;"&gt;GPIO helper functions&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Because we want to use the GPIOs to change a RGB LED colors, we need a way to manipulate them.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;On the Raspberry, one way is to use the interface provided by the OS itself - just writing to special places in the filesystem. To use a GPIO pin, it needs to be:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Exported (writing the pin number to /sys/class/gpio/export does that)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Set to the correct direction (Writing “out” or “in” to /sys/class/gpio/gpio[n]/direction)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Written: (Writing “1” or “0“ to /sys/class/gpio/gpio[n]/value)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Unexported after the program is done (writing the pin number to /sys/class/gpio/unexport) &lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The project comes with four functions that do exactly these tasks.&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style="font-weight: 400;"&gt;Threaded operation&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Because the program works with user input directly read from the console, which is a blocking operation, the statechart is executed in another thread.We use the same thread runner here as in other examples (link auf example seite) which makes use of the standard pthread library. A pthread mutex makes sure the statechart is not accessed by more than one thread at once.&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;span style="font-weight: 400;"&gt;The hardware setup&lt;/span&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;I use a Raspberry Pi 3 Model B V1.2 here, but it should work with every version available. Furthermore, I found a Keyes RGB LED module and a ribbon cable suited for the Pi in our hardware box.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The RGB LED is actually made for 5V signals, but it still works on the 3.3V of the Raspberry Pi – it’s just a lot dimmer than usual. It has four pins: R, G, B, and ground. I connected these to red, green, blue and black ribbons, and on the Pi they are connected with GPIO 16, 20 and 21. You could use any other GPIO but these three have a ground pin directly next to them.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;The statechart&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The statechart contains five states – init, idle, and red / green / blue. For each color, there is an incoming event which switches between idle and the respective color, so you cannot change from red to blue directly – a small example for changing the currently possible behavior depending on the current state. If you would write this logic directly in C, you might end up with a bunch of if-statements.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Raspberry-Pi-YAKINDU-Statechart-Tool_06.png?t=1499164433530&amp;amp;width=724&amp;amp;name=Raspberry-Pi-YAKINDU-Statechart-Tool_06.png" alt="Raspberry-Pi-YAKINDU-Statechart-Tool.png" width="724" title="Raspberry-Pi-YAKINDU-Statechart-Tool.png" style="width: 724px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Compile it, test it, run it, love it&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Running the software on your Pi is surprisingly simple with TCF. At first, make sure the code runs locally. Right click the project and navigate to Build Configurations and activate the Debug setting. Build the project, and then again right click and select Run as… and choose Local C/C++ Application. That should give you the following output:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Failed to open /sys/class/gpio/export for writing, aborting&lt;br&gt;&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;Failed to open /sys/class/gpio/export for writing, aborting&lt;br&gt;&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;Failed to open /sys/class/gpio/export for writing, aborting&lt;br&gt;&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;Failed to open gpio direction for writing!&lt;br&gt;&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;Failed to open gpio direction for writing!&lt;br&gt;&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;Failed to open gpio direction for writing!&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Surprise, these files do not exist in a regular Linux environment.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now, change to the RPi_Cross build configuration, build the project, and run it as a “Remote Application”. Confirm the window that pops up (Your TCF agent should be listed and checked there) and the Eclipse console should show the following:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Eclipse-console_07.png?t=1499164433530&amp;amp;width=725&amp;amp;name=Eclipse-console_07.png" alt="Eclipse-console-statechart-tools-raspberry-pie.png" width="725" style="width: 725px;" title="Eclipse-console-statechart-tools-raspberry-pie.png"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;You should now be able to type in one of the given letters (confirm with enter) and the LED should light up in the respective color. Nice!&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;With this procedure, you can quickly develop your software for the Raspberry Pi, check if it works correctly, and so on. Statechart Tools combined with TCF is the perfect way to keep your iteration times as short as possible.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Summary&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;So, what did you do today?&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;You installed a cross compiler in the blink of an eye&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;You set up TCF to talk with the Raspberry Pi&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;You learned how to use the GPIOs on the Raspberry Pi with C&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;...and all of this completely with open source software! &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/itemis-und-Raspberry-Pi.jpg?t=1499164433530&amp;amp;width=724&amp;amp;height=407&amp;amp;name=itemis-und-Raspberry-Pi.jpg" alt="itemis-und-Raspberry-Pi.jpg" width="724" height="407"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now you want to program your own Raspberry Pi? Then download YAKINDU Statechart Tools!&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fhow-to-program-your-raspberry-pi-with-statechart-tools-in-5-minutes&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Thu, 11 May 2017 13:46:00 GMT</pubDate>
      <author>rene.beckmann@itemis.de (René Beckmann)</author>
      <guid>https://blogs.itemis.com/en/how-to-program-your-raspberry-pi-with-statechart-tools-in-5-minutes</guid>
      <dc:date>2017-05-11T13:46:00Z</dc:date>
    </item>
    <item>
      <title>Pizza, Usability und ein kleines bisschen Romantik</title>
      <link>https://blogs.itemis.com/de/pizza-usability-und-ein-kleines-bisschen-romantik</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/de/pizza-usability-und-ein-kleines-bisschen-romantik" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/Usability/Kollegen-essen-Pizza-am-Laptop.jpg?t=1499164433530" alt="Kollegen-essen-Pizza-am-Laptop.jpg" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Ihr fragt euch, was diese Dinge gemeinsam haben? Die Antwort ist ganz&amp;nbsp;einfach: Ich spreche von einem "Usability-Speed-Testing"!&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Ihr fragt euch, was diese Dinge gemeinsam haben? Die Antwort ist ganz&amp;nbsp;einfach: Ich spreche von einem "Usability-Speed-Testing"!&lt;/span&gt;&lt;/p&gt;  
&lt;h2&gt;&lt;strong&gt;Speed-Testing für schnelles Benutzer-Feedback&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Eine gute Benutzerfreundlichkeit und User Experience sind wichtige Faktoren für das Entwicklerteam von &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt;. An wertvolles Feedback der Nutzer zu kommen, kann jedoch zeit- und kostenintensiv sein – außer ihr nehmt an einem Usability-Speed-Testing teil.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Usability-Speed-Testing… Noch nie davon gehört? Keine Sorge – hier kommen die wichtigsten Fakten: Das Event ist auch als Usability-Speed-Dating oder Usability Dinner bekannt und kommt (wie so viele Dinge) aus der Richtung San Francisco und Silicon Valley. Entwickler können mit Hilfe des Speed-Testings zu schnellem Benutzerfeedback kommen, indem sie ihre Produkte mit zum Testing bringen. Aber wie läuft das Speed-Testing eigentlich ab?&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Entwickler und Anwender aller Erfahrungsstufen versammeln sich in lockerer Atmosphäre. Es gibt Pizza und jeder trinkt, was er mag. 15 Minuten lang testen die Nutzer die Usability jedes Produktes oder Werkzeugs – ähnlich wie beim Speed Dating. Auf diese Weise erhalten die Entwickler wertvolle Einblicke von echten Benutzern, aber mit weniger Zeit- und Kostenaufwand.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/Usability/Kollegen-essen-Pizza-am-Laptop.jpg?t=1499164433530&amp;amp;width=724&amp;amp;name=Kollegen-essen-Pizza-am-Laptop.jpg" alt="Usability-Pizza-und-Statechart-Tools.jpg" width="724" title="Usability-Pizza-und-Statechart-Tools.jpg" style="width: 724px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="/de/usability-dinner-im-speed-test-usability-feedback-sammeln"&gt;Mehr Informationen zum Ablauf eines Usability-Speed-Testing gibt’s in unserem Erfahrungsbericht.&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;User-Feedback für Yakindu Statechart Tools&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Wertvolles Feedback der Nutzer und das auch noch schnell und unkompliziert? Kein Wunder, dass wir mit YAKINDU Statechart Tools teilnahmen, als wir bei itemis unsere letztes Usability Speed-Testing veranstalteten. Unser Testszenario zielte auf den Onboarding-Prozess ab, den ein Erstbenutzer durchlaufen sollte, also den&amp;nbsp;ersten Kontakt nach dem Herunterladen der Anwendung.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Wir suchten nach Erkenntnissen zu Themen wie:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Was ist der allgemeine erste Eindruck von YAKINDU Statechart Tools&amp;nbsp;für einen neuen Benutzer?&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Sind unsere &lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/examples/"&gt;Beispiele&lt;/a&gt; und &lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/tutorials/#oss_five-minutes-tutorial"&gt;Tutorials&lt;/a&gt; zugänglich und leicht verständlich?&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Ist die Benutzeroberfläche intuitiv genug und bieten die Assistenten die Hilfe, die sie&amp;nbsp;sollen?&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Wie interagieren neue Benutzer mit dem grafischen Modell-Editor?&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Können neue Benutzer schnell die Simulationsfunktion eines Kleinmodells begreifen?&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/Usability/Usability%20Speed%20Testing.png?t=1499164433530&amp;amp;width=724&amp;amp;name=Usability%20Speed%20Testing.png" alt="Usability-Speed-Testing-Anwendungen-werden-gestestet.png" width="724" title="Usability-Speed-Testing-Anwendungen-werden-gestestet.png" style="width: 724px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Was haben wir herausgefunden?&lt;/strong&gt;&lt;/h2&gt; 
&lt;h3&gt;&lt;strong&gt;Willkommensseite und Beispiel-Assistent verbessert&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Die Fähigkeit, die Kernfunktionen schnell zu erfassen, ist der Schlüssel für jede Anwendung. Daher haben wir die Begrüßungsseite und den Beispiel-Assistenten überarbeitet,&amp;nbsp;&lt;/span&gt;&lt;span class="s1" style="background-color: transparent;"&gt;sodass diese für Benutzer bei der ersten Verwendung der Anwendung intuitiver sind.&amp;nbsp;&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;Während der Testsitzungen bestätigten unsere Tester die verbesserte Benutzerfreundlichkeit, da sie keine Problem damit hatten, ein geeignetes Startbeispiel zu finden und auszuwählen.&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;Simulation View ist zu schwer zu bemerken&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Als wir unseren Freiwilligen die Aufgabe gaben, ein einfaches Modell zu simulieren, bemerkten wir ein&amp;nbsp;Problem: Die&amp;nbsp;Benutzer hatten Schwierigkeiten, die Simulationsansicht zu finden, die erforderlich ist, um von einem Zustand in den nächsten überzugehen. Im Moment ist diese Ansicht&amp;nbsp;auf der rechten Seite des Bildschirms versteckt und zu unauffällig, um als aktives Panel erkannt zu werden.&lt;/span&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;strong&gt;"Oh wow, ich kann hier schreiben ..."&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Wir haben ein ähnliches Problem mit dem DSL-Editor bemerkt. Auch diesen konnten einige Tester nicht&amp;nbsp;als editierbares Textfeld erkennen, da er auf den ersten Blick nicht den Erwartungen, wie solche Felder aussehen sollen, entspricht. Erst nach einem Doppelklick ändert sich das visuelle Erscheinungsbild – dies war für die Nutzer jedoch nicht ersichtlich.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/Usability/Testing%20YAKINDU%20Statechart%20Tools-1.jpg?t=1499164433530&amp;amp;width=640&amp;amp;name=Testing%20YAKINDU%20Statechart%20Tools-1.jpg" alt="Testing-YAKINDU-Statechart-Tools-itemis-usability-speed-testing.jpg" width="640" style="display: block; margin-left: auto; margin-right: auto; width: 640px;" title="Testing-YAKINDU-Statechart-Tools-itemis-usability-speed-testing.jpg"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Schnelle, aber wertvolle Ergebnisse&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Nach dem Speed-Testing hatten wir Feedback &amp;nbsp;von Testern gesammelt, die unterschiedlicher nicht hätten sein können.&amp;nbsp;Es waren Eclipse-Experten aber&amp;nbsp;auch echte Erstbenutzer dabei. Während wir einige der Rückmeldungen erwartet hatten, haben wir auch völlig neue Dinge erfahren können – und&amp;nbsp;Feedback ist uns wichtig. Nur durch echte Nutzerrückmeldungen können wir&amp;nbsp;YAKINDU Statechart Tools zu einem noch besseren Produkt machen.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;So war das&amp;nbsp;Usability Speed-Testing ein großartiges Event mit jeder Menge wertvoller Ergebnisse für uns – und außerdem hatten wir eine tolle Zeit!&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Ihr wollt es auch mal ausprobieren? Dann meldet euch einfach bei uns – &lt;a href="https://www.eventbrite.de/e/itemis-usability-speed-testing-in-bonn-tickets-31414852670"&gt;das nächste Speed-Testing findet am 10.05. in Bonn statt&lt;/a&gt;&amp;nbsp;–&amp;nbsp;oder lest euch im Blog weiter in das Thema ein.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=d7cc7561-dcea-4077-aabb-c0331ca2feb1&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Erfahrt mehr zum Usability-Speed-Testing" src="https://no-cache.hubspot.com/cta/default/761475/d7cc7561-dcea-4077-aabb-c0331ca2feb1.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fde%2Fpizza-usability-und-ein-kleines-bisschen-romantik&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Usability</category>
      <category>#AMUX</category>
      <pubDate>Fri, 05 May 2017 10:55:00 GMT</pubDate>
      <author>eiterig@itemis.de (Simon Eiterig)</author>
      <guid>https://blogs.itemis.com/de/pizza-usability-und-ein-kleines-bisschen-romantik</guid>
      <dc:date>2017-05-05T10:55:00Z</dc:date>
    </item>
    <item>
      <title>Welches Werkzeug brauche ich für die Modellierung mit Zustandsautomaten?</title>
      <link>https://blogs.itemis.com/de/welches-werkzeug-brauche-ich-f%C3%BCr-die-modellierung-von-zustandsautomaten</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/de/welches-werkzeug-brauche-ich-für-die-modellierung-von-zustandsautomaten" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/Werkzeuge-und-Computertechnologie.jpg?t=1499164433530" alt="Welches Werkzeug brauche ich für die Modellierung mit Zustandsautomaten?" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In meinem letzten Artikel habe ich euch von Emil erzählt. Er und sein Entwicklerteam kamen mit der &lt;a href="/de/brauchen-auch-werkzeugketten-ein-refactoring"&gt;Weiterentwicklung in ihrem Projekt&lt;/a&gt; nicht mehr weiter. Ihr Modellierungswerkzeug behinderte ihre Arbeit bei der Entwicklung einer s&lt;span&gt;elbstregulierenden Steuerung für Ampelsysteme&amp;nbsp;&lt;/span&gt;mehr als es sie unterstützte.&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In meinem letzten Artikel habe ich euch von Emil erzählt. Er und sein Entwicklerteam kamen mit der &lt;a href="/de/brauchen-auch-werkzeugketten-ein-refactoring"&gt;Weiterentwicklung in ihrem Projekt&lt;/a&gt; nicht mehr weiter. Ihr Modellierungswerkzeug behinderte ihre Arbeit bei der Entwicklung einer s&lt;span&gt;elbstregulierenden Steuerung für Ampelsysteme&amp;nbsp;&lt;/span&gt;mehr als es sie unterstützte.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Nun setzten sie sich zusammen und definierten die Anforderungen an ihr Modellierungswerkzeug neu – denn klar definierte Anforderungen sind die notwendige Grundlage für die Wahl eines Modellierungswerkzeug, welches das Team unterstützt und voranbringt. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Modellierungswerkzeuge gibt es reichlich. Es gibt die großen und teuren, die alles können (möchten). Kleinere Programme haben meist weniger Features. Doch wenn dies genau diejenigen Features sind, die unser Projekt braucht, was wollen wir mehr?&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Für Zustandsautomaten ist vielleicht &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt; das richtige Werkzeug. Diese Software bündelt Modellierung, Simulation und Codegenerierung von Finite-StateMachines zu einem schlanken, robusten Werkzeug. Sowohl UML-2.0-, Harel-, Mealy- und Moore-Automaten sind möglich. Die großen Stärken der Statechart Tools sind der Simulator und die anpassbare Codegenerierung für verschiedene Zielsprachen wie C, C++ oder Java. Auch ein selbst geschriebener Generator für eine eigene Zielsprache (vgl. &lt;/span&gt;&lt;a href="https://de.wikipedia.org/wiki/Dom%C3%A4nenspezifische_Sprache"&gt;&lt;span style="font-weight: 400;"&gt;domänenspezifische Sprachen&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;) ist realisierbar.&lt;/span&gt;&amp;nbsp;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Was kann YAKINDU Statechart Tools, das andere nicht können?&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Seit nunmehr zehn Jahren wird YAKINDU Statechart Tools entwickelt, so dass wir es zu den ausgereiften Werkzeugen zählen dürfen, ähnlich Enterprise Architect, Matlab Simulink oder Stateflow. Enterprise Architect besitzt jedoch keine formale Ausdruckssprache und als Konsequenz daraus keine Möglichkeit der Validierung, keine Code Completion und keine Typsicherheit bei allen formalen Ausdrücken. Die Fähigkeit der adäquaten &lt;/span&gt;&lt;a href="/en/eclipse-based-uml-validation-of-enterprise-architect-models"&gt;&lt;span style="font-weight: 400;"&gt;Simulation und Validierung wird dadurch ebenfalls beschränkt&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;. Hier liegt die Stärke von YAKINDU Statechart Tools.&lt;/span&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Für Embedded-Entwickler bietet YAKINDU Statechart Tools die Möglichkeit, auf eigenen C-Variablen, -Konstanten oder -Funktionen direkt aus dem Zustandsautomaten heraus zuzugreifen. Arbeitet ein Team mit anderen Werkzeugen, die eine derart weitreichende C-Integration nicht bieten, werden sie zahlreiche Arbeitsstunden in die Verknüpfung von Modell und C-Code stecken. Diese Zeit lässt sich sinnvoller nutzen…&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Das Headless-Build-Feature ermöglicht es, den Codegenerator in den automatischen Build-Prozess einzubinden – ebenfalls ohne wertvolle Arbeitsstunden in das manuelle Anstoßen der Codegenerierung über die grafische Oberfläche des Werkzeugs &amp;nbsp;stecken zu müssen. Die Codegenerierung erfolgt ohne weiteres Zutun automatisch innerhalb des Build-Prozesses.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Welche Anforderungen müssen erfüllt werden?&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Ein Werkzeug muss nicht umfassend, groß und monolithisch sein. Es muss nur genau die richtigen Features bieten, welche die Entwicklung heute voranbringen. Was zählt, ist die Entwicklung hier und jetzt, nicht Projekte und Themen, die vielleicht in Zukunft auch noch kommen werden.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Emils Team hat seine Anforderungen noch einmal überarbeitet. Das größte Problem des Modellierungswerkzeugs ist der Generator. Er macht dem Team mehr Probleme, als er löst. Das für Emils Team perfekte Modellierungstool…&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;… unterstützt UML 2.0-Zustandsautomaten,&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;… kann verlässlich validieren und simulieren,&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;… besitzt einen leistungsstarken, konfigurierbaren Generator für C, der vorhersehbaren Quellcode produziert,&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;… lässt sich einfach in den bestehenden Build-Prozess integrieren.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Wenn man sich die oben beschriebenen Features anschaut, könnte es sein, dass YAKINDU Statechart Tools eine passende Lösung ist. Denn vor allem die Typsicherheit ermöglicht eine verlässliche Modellvalidierung. Sie bietet eine belastbare Basis für Codegenerierung. Dass sich YAKINDU Statechart Tools einfach in den Build-Prozess integrieren lässt, spart Arbeitszeit der Entwickler&amp;nbsp;und diese können sich auf das eigentliche Entwicklungsziel konzentrieren und sind weniger durch Aufgaben abgelenkt, die nicht direkt zum Produkt beitragen. &lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Ich bin gespannt, was mir Emil demnächst berichtet. Für welches Werkzeug entscheidet sich das Team? Wie wird die Migration? Ich werde berichten.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Übrigens: Wenn ihr YAKINDU Statechart Tools selbst einmal ausprobieren möchtet, ladet es euch einfach auf unserer Website herunter.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fde%2Fwelches-werkzeug-brauche-ich-f%C3%BCr-die-modellierung-von-zustandsautomaten&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Thu, 04 May 2017 12:54:00 GMT</pubDate>
      <author>svenja.wendler@itemis.de (Svenja Wendler)</author>
      <guid>https://blogs.itemis.com/de/welches-werkzeug-brauche-ich-f%C3%BCr-die-modellierung-von-zustandsautomaten</guid>
      <dc:date>2017-05-04T12:54:00Z</dc:date>
    </item>
    <item>
      <title>Brauchen auch Werkzeugketten ein Refactoring?</title>
      <link>https://blogs.itemis.com/de/brauchen-auch-werkzeugketten-ein-refactoring</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/de/brauchen-auch-werkzeugketten-ein-refactoring" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/Vera%CC%88nderungen.jpg?t=1499164433530" alt="Veränderungen.jpg" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Neulich traf ich Emil, den erfahrenen Entwickler. Weil er überarbeitet aussah, fragte ich ihn, was denn los sei. Als hätte er darauf gewartet, sprudelte er los: „Es geht nicht mehr, es geht einfach nicht mehr, wir kommen nicht weiter.“&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Neulich traf ich Emil, den erfahrenen Entwickler. Weil er überarbeitet aussah, fragte ich ihn, was denn los sei. Als hätte er darauf gewartet, sprudelte er los: „Es geht nicht mehr, es geht einfach nicht mehr, wir kommen nicht weiter.“&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Ich erfuhr, dass die Weiterentwicklung in seinem Projekt seit Wochen stagniert. Das Team versucht, eine selbstregulierende Steuerung für Ampelsysteme zu entwickeln, doch es kämpft täglich mit Unzulänglichkeiten, wenn nicht Unzumutbarkeiten, ihrer Entwicklungssoftware. Die Entwickler arbeiten modellbasiert. Klingt fortschrittlich. Ist es aber nicht immer, wenn das Modellierungstool nicht zum Projekt passt – und genau das ist in Emils Projekt der Fall.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Er und seine Kollegen arbeiten mit einem in anderen Projekten bewährten Modellierungstool, schimpfen aber ständig darüber, dass der Code, den sie aus ihrem Statechart-Modell generieren, schlecht konfigurierbar sei. Der Codegenerator unterstütze nur C++03. Sie brauchen aber C++11 und C++14, erläutert Emil. Gleichzeitig gibt es keine Schnittstelle, um den Generator anzupassen. Sie ver(sch)wenden viel Zeit in umständlichen Workarounds, um nutzbare Ergebnisse zu erhalten. Immerhin hat Emil erkannt, dass es so nicht weitergehen kann – und Einsicht ist bekanntlich der erste Schritt zur Besserung. Doch was nun?&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Rückbesinnung auf die wirklich wichtigen Fragen&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In solchen Phasen erweist es sich häufig als hilfreich, zu stoppen und innezuhalten, um Abstand von der alltäglichen Arbeit zu bekommen. Für das Projektteam kann das bedeuten, sich einen &lt;/span&gt;&lt;a href="/de/4-1-gewinnt-das-etwas-andere-arbeitszeitmodell"&gt;&lt;span style="font-weight: 400;"&gt;Labday&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; zu gönnen und sich auf die folgenden Fragen zu besinnen:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Welche Funktionen unseres Tools benutzen wir – und welche brauchen wir? Besitzt das Tool diese Funktionalitäten?&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Entsprechen die vorhandenen Funktionen unseren Anforderungen?&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Welche Anforderungen haben wir eigentlich an so ein Tool?&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Welche Alternativen gibt es, die besser zu uns passen?&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Vera%CC%88nderungen.jpg?t=1499164433530&amp;amp;width=724&amp;amp;name=Vera%CC%88nderungen.jpg" alt="Refactoring-von-Werkzeugketten-bringt-positive-Veränderungen.jpg" width="724" title="Refactoring-von-Werkzeugketten-bringt-positive-Veränderungen.jpg" style="width: 724px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Diese Fragen bauen zum Teil aufeinander auf – und ihre Beantwortung kann und sollte im Zweifel zu einem Toolwechsel führen. Parallel kann das Team natürlich schon nach alternativen Tools suchen.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Um sich für das richtige Werkzeug zu entscheiden, sind die Anforderungen entscheidend: Welche Funktionen sind uns wirklich wichtig und auf welche können wir gegebenfalls auch verzichten? Diese Anforderungen ergeben sich idealerweise auch aus den Unzulänglichkeiten des aktuellen Werkzeugs. So ist dieses dann doch noch zu etwas zu gebrauchen ;)&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Auch wenn die Entscheidung sicher nicht einfach ist und (vorerst) eine Menge zusätzlicher Arbeit mit sich bringt: Auf lange Sicht ist es nicht zielführend, mit einem Tool zu arbeiten, das weder den Ansprüchen des Teams noch den Anforderungen des Projektes gerecht wird. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Tauscht das Team das Werkzeug aber aus, wird die Werkzeugkette wieder fit für die aktuelle Entwicklung – &lt;/span&gt;&lt;a href="/en/refactor-state-machine-yakindu-statechart-tools"&gt;&lt;span style="font-weight: 400;"&gt;so wie Refactorings auch Code oder Modelle fit halten&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;. Auf lange Sicht wird das Team mit einem passenden Werkzeug produktiver und sowohl Zeit- als auch Kostenaufwände werden reduziert.&lt;/span&gt;&lt;/p&gt; 
&lt;p class="p1"&gt;&lt;span style="font-weight: 400;"&gt;Doch wie finden Entwickler wie Emil heraus, welches Modellierungswerkzeug das richtige für ihr Projekt ist?&lt;/span&gt;&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;&lt;/p&gt; 
&lt;p class="p1"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=1f2f87e5-cabf-43d1-b534-83c5b42110f9&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Hier mehr&amp;nbsp;erfahren:  Welches Werkzeug brauche ich für die Modellierung mit Zustandsautomaten?" src="https://no-cache.hubspot.com/cta/default/761475/1f2f87e5-cabf-43d1-b534-83c5b42110f9.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fde%2Fbrauchen-auch-werkzeugketten-ein-refactoring&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Thu, 04 May 2017 08:57:00 GMT</pubDate>
      <author>svenja.wendler@itemis.de (Svenja Wendler)</author>
      <guid>https://blogs.itemis.com/de/brauchen-auch-werkzeugketten-ein-refactoring</guid>
      <dc:date>2017-05-04T08:57:00Z</dc:date>
    </item>
    <item>
      <title>Modellieren mit Zustandsautomaten (Teil 5): Das State Pattern</title>
      <link>https://blogs.itemis.com/de/modellieren-mit-zustandsautomaten-teil-5-das-state-pattern</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/de/modellieren-mit-zustandsautomaten-teil-5-das-state-pattern" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/Fensterfront-la%CC%88sst-Licht-rein.jpg?t=1499164433530" alt="Fensterfront-lässt-Licht-rein.jpg" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p class="p1"&gt;Nachdem wir die &lt;a href="/de/modellieren-mit-zustandsautomaten-teil-1"&gt;Modellierung von Zustandsautomaten&lt;/a&gt; und ihre Realisierung mit Hilfe von &lt;a href="/de/modellieren-mit-zustandsautomaten-teil-3-die-gro%C3%9Fe-switch-anweisung"&gt;Switch-Anweisung&lt;/a&gt; und &lt;a href="/de/modellieren-mit-zustandsautomaten-teil-4-darstellung-als-tabelle"&gt;Tabelle&lt;/a&gt; kennengelernt haben, schauen wir uns nun eine objektorientierte Implementierungsvariante an: das State Pattern. Anschließend vergleichen wir die drei Varianten.&lt;/p&gt;</description>
      <content:encoded>&lt;p class="p1"&gt;Nachdem wir die &lt;a href="/de/modellieren-mit-zustandsautomaten-teil-1"&gt;Modellierung von Zustandsautomaten&lt;/a&gt; und ihre Realisierung mit Hilfe von &lt;a href="/de/modellieren-mit-zustandsautomaten-teil-3-die-gro%C3%9Fe-switch-anweisung"&gt;Switch-Anweisung&lt;/a&gt; und &lt;a href="/de/modellieren-mit-zustandsautomaten-teil-4-darstellung-als-tabelle"&gt;Tabelle&lt;/a&gt; kennengelernt haben, schauen wir uns nun eine objektorientierte Implementierungsvariante an: das State Pattern. Anschließend vergleichen wir die drei Varianten.&lt;/p&gt;  
&lt;p class="p1"&gt;Das Software-Entwurfsmuster State Pattern verwenden etwa Spring Statemachine, Boost Meta State Machine (MSM) oder das Qt State Machine Framework. Es zählt zu den Verhaltensmustern (behavioral design patterns) und kapselt das zustandsabhängige Verhalten eines Objekts nach außen hin. Jeder Zustand ist als eine eigene Klasse implementiert, die das Verhalten des Automaten in diesem Zustand definiert. Alle Zustandsklassen leiten sich von einem gemeinsamen Interface ab, so dass sich sämtliche Zustände einheitlich behandeln lassen.&lt;br&gt;&lt;br&gt;Das Klassendiagramm der Jalousiesteuerung sieht so aus:&lt;br&gt;&lt;br&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Klassendiagramm-einer-Jalousiesteuerung.png?t=1499164433530&amp;amp;width=724&amp;amp;name=Klassendiagramm-einer-Jalousiesteuerung.png" alt="Klassendiagramm-von-Zustandsautomaten-einer-Jalousiesteuerung.png" width="724" title="Klassendiagramm-von-Zustandsautomaten-einer-Jalousiesteuerung.png" style="width: 724px;"&gt;&lt;br&gt;&lt;br&gt;Das Interface &lt;em&gt;State&lt;/em&gt; definiert diejenigen Methoden, deren Verhalten zustandsabhängig ist. Neben den mit &lt;em&gt;raise…&lt;/em&gt; beginnenden Methode zum Auslösen eines Event gibt es hier die Methode &lt;em&gt;getName&lt;/em&gt;, die den Name des Zustands zurückgibt.&lt;br&gt;&lt;br&gt;Die Klasse &lt;em&gt;StateMachine&lt;/em&gt; repräsentiert den Zustandsautomaten. Sie verwaltet die dem aktiven Zustand entsprechende Klasse und damit das zustandsspezifische Verhalten im Attribut activeState. Damit ähnelt das State Pattern dem Strategy Pattern, wobei ein Zustand einer Strategie entspricht, sprich: der Implementierung eines konkreten Verhaltens. Während die Strategie im Strategy Pattern aber von außen gesetzt wird, kümmern sich die Zustände im State Pattern selbst darum. Wenn man so will, ersetzt im State Pattern eine "Strategie" sich selbst durch eine andere, oder in der richtigen Nomenklatur: Ein Zustand aktiviert seinen Folgezustand selbst.&lt;br&gt;&lt;br&gt;Schauen wir uns das am Beispiel näher an: Die Client-Anwendung sendet Nachrichten an den Zustandsautomaten, indem sie &lt;em&gt;StateMachine&lt;/em&gt;-Methoden aufruft. Nehmen wir an, der Benutzer drückt die [↓]-Taste. Der Client informiert den Zustandsautomaten über diese Aktion durch Aufruf der Methode &lt;em&gt;raiseUserDown&lt;/em&gt;. Die Reaktion des Automaten hängt vom aktiven Zustand ab:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li class="p1"&gt;Im Zustand &lt;strong&gt;Moving up&lt;/strong&gt; wechselt der Automat in den Zustand &lt;strong&gt;Idle&lt;/strong&gt;. &lt;/li&gt; 
 &lt;li class="p1"&gt;Im Zustand &lt;strong&gt;Idle&lt;/strong&gt; wechselt der Automat in den Zustand &lt;strong&gt;Moving down&lt;/strong&gt;.  &lt;/li&gt; 
 &lt;li class="p1"&gt;Im Zustand &lt;strong&gt;Moving down&lt;/strong&gt; ignoriert der Automat das Ereignis. &lt;/li&gt; 
&lt;/ul&gt; Daher delegiert 
&lt;em&gt;StateMachine&lt;/em&gt; den Aufruf an die entsprechende Methode des aktiven Zustandsobjekts. Die 
&lt;em&gt;StateMachine&lt;/em&gt;-Methode 
&lt;em&gt;raiseUserDown&lt;/em&gt; ruft die gleichnamige Methode von 
&lt;em&gt;activeState&lt;/em&gt; auf:
&lt;br&gt;
&lt;br&gt; 
&lt;pre class="prettyprint"&gt;public void raiseUserDown() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;activeState.raiseUserDown();&lt;br&gt;}&lt;/pre&gt; 
&lt;p class="p1"&gt;&lt;br&gt;Was nun geschieht, entscheidet das Zustandsobjekt. Handelt es sich um ein Objekt der Klasse &lt;em&gt;Idle&lt;/em&gt;, erfolgt ein Zustandsübergang zu &lt;strong&gt;Moving down&lt;/strong&gt;. So sieht &lt;em&gt;raiseUserDown&lt;/em&gt; in &lt;em&gt;Idle&lt;/em&gt; aus:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;public void raiseUserDown() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.activateState(new MovingDown(stateMachine));&lt;br&gt;}&lt;/pre&gt; 
&lt;p class="p1"&gt;&lt;br&gt;Die Methode aktiviert den neuen Zustand durch Übergabe eines entsprechenden Zustandsobjekts an die &lt;em&gt;StateMachine&lt;/em&gt;-Methode &lt;em&gt;activateState&lt;/em&gt;, die es &lt;em&gt;activeState&lt;/em&gt; zuweist.&lt;br&gt;Befindet sich der Automat hingegen im Zustand &lt;strong&gt;Moving down&lt;/strong&gt;, soll beim Aufruf von &lt;em&gt;raiseUserDown&lt;/em&gt; nichts geschehen. Die Klasse &lt;em&gt;MovingDown&lt;/em&gt; implementiert diese Methode daher gar nicht. Es "zieht" vielmehr die &lt;em&gt;raiseUserDown&lt;/em&gt;-Implementierung der Oberklasse &lt;em&gt;AbstractState&lt;/em&gt;:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;public void raiseUserDown() {&lt;br&gt;}&lt;/pre&gt; 
&lt;p class="p1"&gt;&lt;br&gt;Diese Methode tut nichts und ignoriert somit das Ereignis – in unserem Fall ein sinnvolles Standardverhalten für alle Ereignisse, für die die jeweilige konkrete Zustandsklasse kein Verhalten implementiert.&lt;/p&gt; 
&lt;h2 class="p1"&gt;Quellcode der Beispielanwendung&lt;/h2&gt; 
&lt;p class="p1"&gt;&lt;br&gt;Hier der Quellcode der Jalousiesteuerung in der Implementierung gemäß dem State Pattern. Der Zustandsautomat besteht aus sechs Klassen; hinzu kommt eine Client-Klasse, die den Automaten nutzt.&lt;br&gt;&lt;br&gt;Das Interface &lt;em&gt;State&lt;/em&gt; spezifiziert, was in der Beispielanwendung ein Zustand ist:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;&lt;br&gt;&lt;br&gt;public interface State {&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserUp();&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserDown();&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raisePosSensorUpperPosition();&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raisePosSensorLowerPosition();&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public String getName();&lt;br&gt;&lt;br&gt;}&lt;/pre&gt; 
&lt;p class="p1"&gt;&lt;br&gt;Die abstrakte Klasse &lt;em&gt;AbstractState&lt;/em&gt; implementiert den Bezug zur &lt;em&gt;StateMachine&lt;/em&gt; und das Standardverhalten für Events, nämlich diese zu ignorieren:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;&lt;br&gt;&lt;br&gt;abstract public class AbstractState implements State {&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;protected StateMachine stateMachine;&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public AbstractState(StateMachine stateMachine) {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;this.stateMachine = stateMachine;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserUp() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserDown() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raisePosSensorUpperPosition() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raisePosSensorLowerPosition() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;abstract public String getName();&lt;br&gt;&lt;br&gt;}&lt;/pre&gt; 
&lt;p class="p1"&gt;&lt;br&gt;Die Klassen &lt;em&gt;Idle&lt;/em&gt;, &lt;em&gt;MovingUp&lt;/em&gt; und &lt;em&gt;MovingDown&lt;/em&gt; repräsentieren die drei konkreten Zustände:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;&lt;br&gt;&lt;br&gt;public class Idle extends AbstractState {&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public Idle(StateMachine stateMachine) {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;super(stateMachine);&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserUp() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.activateState(new MovingUp(stateMachine));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserDown() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.activateState(new MovingDown(stateMachine));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public String getName() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return "Idle";&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt;}&lt;br&gt;&lt;br&gt;package de.itemis.state_machine.example.state_pattern;&lt;br&gt;&lt;br&gt;public class MovingUp extends AbstractState {&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public MovingUp(StateMachine stateMachine) {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;super(stateMachine);&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserDown() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.activateState(new Idle(stateMachine));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raisePosSensorUpperPosition() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.activateState(new Idle(stateMachine));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public String getName() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return "Moving up";&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt;}&lt;br&gt;&lt;br&gt;package de.itemis.state_machine.example.state_pattern;&lt;br&gt;&lt;br&gt;public class MovingDown extends AbstractState {&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public MovingDown(StateMachine stateMachine) {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;super(stateMachine);&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserUp() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.activateState(new Idle(stateMachine));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raisePosSensorLowerPosition() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.activateState(new Idle(stateMachine));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;@Override&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public String getName() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return "Moving down";&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt;}&lt;/pre&gt; 
&lt;br&gt;Die Klasse 
&lt;em&gt;StateMachine&lt;/em&gt; ist das "Gesicht" des Zustandsautomaten nach außen hin:
&lt;br&gt;
&lt;br&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;&lt;br&gt;&lt;br&gt;public class StateMachine {&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public StateMachine() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;activateState(new Idle(this));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;State activeState = null;&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void activateState(State state) {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;activeState = state;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public State getActiveState() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return activeState;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserUp() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;activeState.raiseUserUp();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raiseUserDown() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;activeState.raiseUserDown();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raisePosSensorUpperPosition() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;activeState.raisePosSensorUpperPosition();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public void raisePosSensorLowerPosition() {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;activeState.raisePosSensorLowerPosition();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt;}&lt;/pre&gt; 
&lt;p class="p1"&gt;&lt;br&gt;Und so wird der Zustandsautomat vom Anwendungscode aus genutzt:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;&lt;br&gt;&lt;br&gt;import java.io.BufferedReader;&lt;br&gt;import java.io.IOException;&lt;br&gt;import java.io.InputStreamReader;&lt;br&gt;&lt;br&gt;public class Example {&lt;br&gt;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;public static void main(String[] args) throws IOException {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;StateMachine stateMachine = new StateMachine();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.activateState(new Idle(stateMachine));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;BufferedReader console = new BufferedReader(new InputStreamReader(System.in));&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while (true) {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Active state: " + stateMachine.getActiveState().getName());&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.print("Please enter event number! ");&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.print("1: User.up, 2: User.down, 3: PosSensor.upperPosition, ");&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("4: PosSensor.lowerPosition");&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;String line = console.readLine();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;int eventNr = -1;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;eventNr = Integer.parseInt(line);&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} catch (NumberFormatException ex) {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;eventNr = -1;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;switch (eventNr) {&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 1:&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.raiseUserUp();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 2:&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.raiseUserDown();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 3:&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.raisePosSensorUpperPosition();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;case 4:&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;stateMachine.raisePosSensorLowerPosition();&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;default:&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;System.out.println("Unknown event number: " + eventNr + ".");&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;break;&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;&lt;br&gt;}&lt;/pre&gt; 
&lt;p&gt;&lt;br&gt;Übrigens ist für das State Pattern nicht zwingend eine objektorientierte Programmiersprache nötig. Es lässt sich auch mit einer imperativen Sprache umsetzen, sofern diese über Funktionszeiger verfügt, wie beispielsweise C. Der Wesenskern des State Patterns ist, dass der aktive Zustand auf Ereignisse reagiert und gegebenenfalls einen anderen Zustand aktiviert.&lt;br&gt;Bei einer C-Implementierung gehört zu jedem Zustand eine Funktion ("Zustandsfunktion"), die diese Aktionen implementiert. Der Zustandsautomat merkt sich den aktiven Zustand durch einen Zeiger auf dessen Zustandsfunktion. Diese liefert als Rückgabewert den Zeiger auf den nächsten Zustand, genau: auf dessen Zustandsfunktion.&lt;/p&gt; 
&lt;h2&gt;Welcher Implementierungsansatz ist der beste?&lt;/h2&gt; 
&lt;p&gt;Für "richtige" Computer wie Notebooks, Desktop-PCs oder Server fallen die Unterschiede zwischen den betrachteten Implementierungsansätzen nicht wirklich ins Gewicht. Anders sieht es bei eingebetteten Geräten (embedded devices) aus, die in puncto Speicherplatz oder CPU-Leistung typischerweise stark eingeschränkt sind. Hier lautet die klare Antwort: Es kommt darauf an.&lt;br&gt;&lt;br&gt;Erfahrungsgemäß sind Zustandsautomaten sehr schnell. Bei einem Zustandsautomaten mit wenigen Zuständen und wenigen Events lohnen sich Optimierungsüberlegungen daher kaum. Anders sieht es bei einer hohen Anzahl von Zuständen oder Events aus. Es soll an dieser Stelle allerdings nicht darum gehen, was genau eine "hohe" Anzahl ist – 500?, 50.000?, 5 Millionen? –, sondern lediglich um einige grundsätzliche Überlegungen.&lt;br&gt;&lt;br&gt;Eine hohe Anzahl von Zuständen bedeutet:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Die Switch-Anweisung enthält sehr viele Fälle.  &lt;/li&gt; 
 &lt;li&gt;Die (eindimensionale) Zustandsübergangstabelle wird sehr hoch. &lt;/li&gt; 
 &lt;li&gt;Das State Pattern benötigt sehr viele Zustandsklassen. &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Ist die Zahl der Events hoch, heißt das:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Innerhalb der einzelnen Fälle in der Switch-Anweisung gibt es – abhängig vom jeweiligen Zustand – viel zu tun. &lt;/li&gt; 
 &lt;li&gt;Die Zustandsübergangstabelle wird sehr breit. &lt;/li&gt; 
 &lt;li&gt;Im State Pattern werden die einzelnen Zustandsklassen – abhängig vom jeweiligen Zustand – recht umfangreich. &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;In allen Implementierungsansätzen setzt sich die Ausführungszeit aus folgenden Elementen zusammen:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Suche nach dem aktiven Zustand &lt;/li&gt; 
 &lt;li&gt;Suche nach Transition anhand des oder der vorliegenden Events &lt;/li&gt; 
 &lt;li&gt;Aktivierung des Folgezustands &lt;/li&gt; 
&lt;/ul&gt; Hinzu kommen die Ausführungszeiten von Guard Conditions und Aktionen. Da diese aber höchst anwendungsspezifisch sind, betrachten wir sie hier nicht weiter. Die Aktivierung des Folgezustands besteht jeweils aus einer einfachen Zuweisung, deren Zeit- und Speicherbedarf wir vernachlässigen können.
&lt;br&gt; 
&lt;h3&gt;Laufzeitbedarf&lt;/h3&gt; 
&lt;p&gt;Für die Suche nach dem aktiven Zustand führt die Switch-Anweisung mindestens einen Vergleich aus, nämlich dann, wenn der erste Fall der Switch-Anweisung bereits der aktive Zustand ist. Schlimmstenfalls benötigt die Switch-Anweisung so viele Vergleiche wie es Zustände gibt, nämlich dann, wenn erst die letzte Case-Klausel den aktiven Zustand behandelt. Sind alle Zustände gleich häufig aktiv, führt die Switch-Anweisung im Mittel &lt;em&gt;z/2&lt;/em&gt; Vergleiche durch, wobei z die Anzahl der Zustände ist. Die Ausführungszeit liegt also in der Größenordnung &lt;em&gt;O(z)&lt;/em&gt;. Es folgt die Analyse, ob bestimmte Events vorliegen, die die entsprechenden Transitionen auszulösen. Die Ausführungszeit hierfür liegt – mit ähnlicher Überlegung wie bei den Zuständen – in der Größenordnung &lt;em&gt;O(e)&lt;/em&gt;, wobei &lt;em&gt;e&lt;/em&gt; die Anzahl der Event-Typen ist.&lt;br&gt;&lt;br&gt;Der Zeitbedarf für die Suche in einer eindimensionalen Zustandsübergangstabelle liegt ebenfalls bei &lt;em&gt;O(z)&lt;/em&gt; + &lt;em&gt;O(e)&lt;/em&gt;. Der erste Term beschreibt die zeilenweisen Suche nach dem aktiven Zustand, der zweite Term steht für die Suche nach einem Event innerhalb der Zeile. Führen vom aktiven Zustand mehrere Transitionen zu unterschiedlichen Folgezuständen, so sind im Allgemeinen mehrere Zeilen zu durchsuchen. An der Größenordnung des Laufzeitbedarfs ändert das aber nichts.&lt;br&gt;&lt;br&gt;Der objektorientierte Ansatz punktet mit einem Zeitbedarf, der von der Anzahl der Zustände unabhängig ist. Da der aktive Zustand bereits als Objekt vorliegt, liegt der Zeitbedarf für die "Suche" nach dem aktiven Zustand in der Größenordnung &lt;em&gt;O(1)&lt;/em&gt;. Der Aufruf der dem Event entsprechenden Methode kommt hinzu. Auf den ersten Blick mag das ebenfalls nach &lt;em&gt;O(1)&lt;/em&gt; aussehen, doch dürfte der Aufwand abhängig von der jeweiligen Sprache und Laufzeitumgebung konservativ geschätzt eher bei &lt;em&gt;O(e)&lt;/em&gt; liegen.&lt;/p&gt; 
&lt;h3&gt;Speicherplatzbedarf&lt;/h3&gt; 
&lt;p&gt;Switch-Anweisung wie Zustandsübergangstabelle müssen sämtliche Kombinationen aus Zustand und Event entweder im Programmcode der Switch-Anweisung oder in den Tabellendaten berücksichtigen. Der Speicherbedarf liegt daher in beiden Fällen in der Größenordnung &lt;em&gt;O(z · e)&lt;/em&gt;. Allerdings belegt die Tabelle davon immer den vollen Umfang, auch wenn sie nur spärlich besetzt ist. Die Switch-Anweisung hingegen braucht nur diejenigen Zustand-/Event-Kombinationen zu kodieren, bei denen ein Event zu einer Transaktion führt. Andererseits belegt ein Funktionszeiger in der Tabelle nur den Speicherplatz einer Adresse, was im Allgemeinen weniger sein dürfte, als der Code einer einzelnen Zustand-/Event-Kombination im Mittel belegt.&lt;br&gt;&lt;br&gt;Im State Pattern enthält jede Zustandsklasse eine Methode für jedes Event, das der jeweilige Zustand berücksichtigt. Wir haben es also ebenfalls mit der Größenordnung &lt;em&gt;O(z·e)&lt;/em&gt; zu tu n. Ähnlich wie bei der Switch-Anweisung brauchen aber nur diejenigen Event-Methoden kodiert zu werden, die etwas anderes bewirken sollen als das in der abstrakten Oberklasse implementierte allgemeine Verhalten für dieses Event. Nur diese Methoden benötigen Speicherplatz für den Programmcode.&lt;/p&gt; 
&lt;h3&gt;ROM- oder RAM-Speicher&lt;br&gt;&lt;br&gt;&lt;/h3&gt; 
&lt;p&gt;Zu bedenken ist, auf welchen Geräten ein Zustandsautomat laufen soll. Objektorientierte Sprachen benötigen in der Regel eine umfangreiche Laufzeitumgebung und mehr RAM, was den Einsatz auf eingebetteten Geräten einschränken oder verhindern kann. Je mehr Programmteile in das unveränderliche ROM passen, desto besser. Ausführbarer Code wie in der Switch-Anweisung fällt in diese Kategorie, ebenso festkodierte Zustandsübergangstabellen. Bei einer objektorientierten Implementierung des State Patterns sollte man statische Zustandsobjekte wiederverwenden statt stets dynamisch neue Objekte im RAM zu erzeugen.&lt;/p&gt; 
&lt;h3&gt;Debug-Fähigkeit&lt;/h3&gt; 
&lt;p&gt;Wichtig ist auch, wie leicht sich eine Statechart-Anwendung während der Entwicklung debuggen lässt. Der Entwickler möchte an bestimmten Stellen seiner Anwendung gern Breakpoints setzen. Dort soll die Anwendung anhalten, damit er sie Schritt für Schritt ausführen und analysieren kann, warum sie sich nicht wie erwartet verhält. In einer State-Klasse ist das recht einfach. Auch Switch-Anweisungen eignen sich. Bei Tabellen kann der Entwickler zwar Breakpoints in den Funktionen setzen, auf die die Funktionsszeiger in der Tabelle verweisen. Aber wenn diese Zeiger in den falschen Zellen stehen, ist die Analyse knifflig.&lt;/p&gt; 
&lt;h3&gt;Verständlichkeit und Wartbarkeit&lt;/h3&gt; 
&lt;p&gt;Überhaupt ist der Code von Zustandsautomaten im Allgemeinen weder übersichtlich noch anschaulich oder verständlich. Am besten schneidet das State Pattern ab, denn es vermeidet eine unübersichtliche und schwer lesbare Switch-Anweisung. Solange ein Zustand nicht zu viele unterschiedliche Events behandeln muss, bleibt er überschaubar. Neue Zustände erfordern lediglich neue Zustandsklassen; eine Änderung des Verhaltens beschränkt sich auf eine Änderung der betroffenen Zustände. Insgesamt verringert sich der Wartungsaufwand.&lt;br&gt;Bei Automaten mit wenigen Zuständen hingegen lohnt sich der Aufwand einer objektorientierten Implementierung nicht unbedingt, weil die Switch-Anweisung in diesem Fall gar nicht so unübersichtlich wäre.&lt;br&gt;&lt;br&gt;Falls ein State-Machine-Framework zur Verfügung steht und sich vom Ressourcenbedarf her für die Zielplattform eignet, sollte es zum Einsatz kommen. Verständlichkeit und Wartbarkeit kann das nur gut tun.&lt;/p&gt; 
&lt;h2&gt;Ausblick: Quellcode automatisch erzeugen&lt;/h2&gt; 
&lt;p&gt;Alle vorgestellten Implementierungsvarianten kranken prinzipbedingt an einer Reihe von Nachteilen:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Keine Form der Implementierung reicht in puncto Anschaulichkeit und Verständlichkeit an das Zustandsdiagramm heran. Je umfangreicher ein Zustandsautomat ist, desto unlesbarer und unüberschaubarer ist seine Darstellung als Programmcode oder Zustandsübergangstabelle.&lt;/li&gt; 
 &lt;li&gt;Die Transformation eines Zustandsdiagramms in eine Implementierung ist aufwendig und fehlerträchtig. &lt;/li&gt; 
 &lt;li&gt;Änderungen am Zustandsdiagramm bedeuten Änderungen an der Implementierung. Dies ist erneut aufwendig, fehlerträchtig und in keiner Weise wartungsfreundlich. &lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Implementierungsaufwand und -komplexität schreien geradezu nach Tool-Unterstützung, so dass sich der Entwickler im Idealfall nur noch um das graphische Statechart zu kümmern braucht. Das werden wir uns im folgenden Teil dieser Serie am Beispiel YAKINDU Statechart Tools näher anschauen.&lt;/p&gt; 
&lt;p&gt;Das Werkzeug könnt ihr euch vorab auch schon kostenfrei bei uns herunterladen.&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fde%2Fmodellieren-mit-zustandsautomaten-teil-5-das-state-pattern&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Thu, 27 Apr 2017 13:46:00 GMT</pubDate>
      <author>rainer.klute@itemis.de (Rainer Klute)</author>
      <guid>https://blogs.itemis.com/de/modellieren-mit-zustandsautomaten-teil-5-das-state-pattern</guid>
      <dc:date>2017-04-27T13:46:00Z</dc:date>
    </item>
    <item>
      <title>Refactor your statechart models</title>
      <link>https://blogs.itemis.com/en/refactor-your-statechart-models</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/refactor-your-statechart-models" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/KEEP-CALM-AND-REFACTOR-MODELS.jpg?t=1499164433530" alt="KEEP-CALM-AND-REFACTOR-MODELS.jpg" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt; has a lot of useful features. In this series we present the "feature of the month" that will help you domesticating your maybe exceeding statechart models.&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt; has a lot of useful features. In this series we present the "feature of the month" that will help you domesticating your maybe exceeding statechart models.&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You may know the renaming refactoring feature of eclipse. This is also possible for statecharts. Select a variable, interface or event and do a right mouseclick. The dialog "Rename" appears.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;More complex are the model refactorings like folding and unfolding actions, extract subdiagram or group states into composite. &lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="https://www.itemis.com/en/yakindu/statechart-tools/documentation/user-guide/#refactorings"&gt;Our documentation explains these features in detail.&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;I will concentrate on the refactorings to fold actions. You can use them to simplify your transitions. During the development of a statemachine you add states, transitions, actions etc. to your model and it grows and grows. If there are multiple transitions leading to one state that have one action in common it is semantically the same if you move it as an entry action to the target state. Then you select your target state and select 'Refactor' – 'Fold Incoming Actions'.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/fold-multiple-transistions-in-a-statechart.png?t=1499164433530&amp;amp;width=724&amp;amp;name=fold-multiple-transistions-in-a-statechart.png" alt="Fold multiple transistions in a statechart model" width="724" title="Fold multiple transistions in a statechart model" style="width: 724px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You can do the same with multiple transitions that leave a state and have some actions in common. The difference is that these are outgoing actions that will be refactored to exit actions of the source state. By doing this you reduce redundancies and increase the readability of your model.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You want to learn more about refactorings? Then check our statecharts-blog!&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=e30796bb-6897-4a7c-9c5f-3bf723adf22e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Learn more about  refactoring your state machine" src="https://no-cache.hubspot.com/cta/default/761475/e30796bb-6897-4a7c-9c5f-3bf723adf22e.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Frefactor-your-statechart-models&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Thu, 20 Apr 2017 14:08:00 GMT</pubDate>
      <author>svenja.wendler@itemis.de (Svenja Wendler)</author>
      <guid>https://blogs.itemis.com/en/refactor-your-statechart-models</guid>
      <dc:date>2017-04-20T14:08:00Z</dc:date>
    </item>
    <item>
      <title>As easy as 1,2,3 – Robot Zowi learns Statecharts</title>
      <link>https://blogs.itemis.com/en/as-easy-as-123-robot-zowi-learns-statecharts</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/as-easy-as-123-robot-zowi-learns-statecharts" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/robot-zowi-and-yakindu-statechart-tools-rule-the-world_725x345.jpg?t=1499164433530" alt="robot-zowi-and-yakindu-statechart-tools-rule-the-world_725x345.jpg" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;     
&lt;p&gt;You know Zowi? No? May I introduce to you: &lt;a href="http://zowi.bq.com"&gt;Zowi&lt;/a&gt; is a robot for kids to teach them programming reactive systems that physically interact with their environment. Zowi walks on two feets, has an ultrasonic distance sensor as eyes, an array of LEDs as mouth, makes sound, and detects noise. It's the perfect match to program it with statecharts.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;You know Zowi? No? May I introduce to you: &lt;a href="http://zowi.bq.com"&gt;Zowi&lt;/a&gt; is a robot for kids to teach them programming reactive systems that physically interact with their environment. Zowi walks on two feets, has an ultrasonic distance sensor as eyes, an array of LEDs as mouth, makes sound, and detects noise. It's the perfect match to program it with statecharts.&lt;/p&gt;  
&lt;p&gt;Very young kids of less than eight years can start playing around with Zowi via a smartphone app. They steer it or execute predefined motion and tone sequences. They can even program it by creating new sequences of the given motion and tone sequences.&lt;/p&gt; 
&lt;p&gt;When they are getting older, kids may program more complex interactions for Zowi by using a &lt;a href="http://bitbloq.bq.com"&gt;web based visual block language&lt;/a&gt; or program it directly with C/C++. Since Zowi is based on the well known Arduino Uno microprocesser ATmega328, it might also be programmed with the &lt;a href="https://www.arduino.cc/"&gt;Arduino tool chain&lt;/a&gt;.&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU/Zowi_and_YAKINDU_SCT_rule_the_World.jpg?t=1499164433530&amp;amp;width=640&amp;amp;name=Zowi_and_YAKINDU_SCT_rule_the_World.jpg" alt="Robot Zowi standing on laptop with YAKINDU statechart tools opened" style="width: 640px; display: block; margin-left: auto; margin-right: auto;" title="Robot Zowi standing on laptop with YAKINDU statechart tools opened" width="640"&gt;&lt;/p&gt; 
&lt;p&gt;Anyway, all of these programming concepts are based on classical imperative programming techniques. Reactive systems like robots are in fact a perfect match to be modelled with state machines. A state machine defines possible states of a system and changes the system's current state by reacting on events from the outside or by a timing schedule.&lt;/p&gt; 
&lt;h2&gt;Let Zowi learn to walk&lt;/h2&gt; 
&lt;p&gt;Let's consider a typical, simple scenario for a robot. Zowi should walk straight ahead until it detects an obstacle. In this case Zowi turns left to avoid the obstacle and goes on with walking. After some time, Zowi gets tired and needs to rest. When sleeping, Zowi wakes up if it hears some noise and begins to walk again.&lt;/p&gt; 
&lt;p&gt;Programming this scenario in pure C or C++ is no fun. Using a lot of IFs and ELSEs causes the code to get lengthy and unreadable. There are various techniques like encapsulation to mitigate this but it's still uncomfortable programming. It lets you loose your focus on modelling the robot's behaviour.&lt;/p&gt; 
&lt;p&gt;Why not just model the state machine by a visually appealing statechart and let the computer do the rest? Let the computer generate the code for the state machine and never touch it again. Concentrate on modelling the system's behaviour.&lt;/p&gt; 
&lt;p&gt;&lt;a href="http://www.statecharts.org"&gt;YAKINDU Statechart Tools&lt;/a&gt;&amp;nbsp;(YAKINDU SCT)&amp;nbsp;brings to you a visual DSL (Domain Specific Language) for state machines and code generators for various languages like C, C++, or Java. In my last blog post &lt;a href="/en/program-an-arduino-with-statemachines-in-5-minutes"&gt;I wrote about how to program an Arduino Uno with YAKINDU Statechart Tools&lt;/a&gt;. I introduced &lt;a href="https://github.com/wendehals/arduino_sct_tools"&gt;YAKINDU Statechart Tools for Arduino&lt;/a&gt; that adds a special C++ source code generator to YAKINDU SCT for various well known and widely used microprocessors like ATmega328, ATmega2560, ATmega32u4, ESP8266, and their derivates.&lt;/p&gt;  
&lt;div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;"&gt;
 &lt;div class="wistia_responsive_wrapper" style="height:100%;left:0;position:absolute;top:0;width:100%;"&gt;
  &lt;span class="wistia_embed wistia_async_j2z9uc381o  videoFoam=true" style="display:inline-block;height:100%;width:100%"&gt;undefined&lt;/span&gt;
 &lt;/div&gt;
&lt;/div&gt;  
&lt;p&gt;Have a look at this short video to see how simple it is to program Zowi based on statecharts with YAKINDU Statechart Tools. I modelled exactly the scenario described above with a statechart and generated the code. After programming some glue code to link the hardware with the state machine and vice versa, I compiled the code and uploaded it to Zowi. Finally, Zowi acts like i planned it. It's that easy! If you like it, use the toolkit for your own robot or IoT projects. You can download &lt;a href="http://www.statecharts.org"&gt;YAKINDU Statechart Tools&lt;/a&gt; and &lt;a href="https://github.com/wendehals/arduino_sct_tools"&gt;YAKINDU Statechart Tools for Arduino&lt;/a&gt; for free!&lt;/p&gt; 
&lt;p&gt;Have fun!&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fas-easy-as-123-robot-zowi-learns-statecharts&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>Arduino</category>
      <category>State Machine</category>
      <pubDate>Tue, 11 Apr 2017 17:10:00 GMT</pubDate>
      <author>lothar.wendehals@itemis.de (Lothar Wendehals)</author>
      <guid>https://blogs.itemis.com/en/as-easy-as-123-robot-zowi-learns-statecharts</guid>
      <dc:date>2017-04-11T17:10:00Z</dc:date>
    </item>
    <item>
      <title>How to program a MSP430 with State Machines in 5 minutes</title>
      <link>https://blogs.itemis.com/en/how-to-program-a-msp430-with-state-machines-in-5-minutes</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/how-to-program-a-msp430-with-state-machines-in-5-minutes" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/msp430-microcontroller-programmed-with-state-machines-with-yakindu-state-chart-tools_725x345.jpg?t=1499164433530" alt="msp430-microcontroller-programmed-with-state-machines-with-yakindu-state-chart-tools_725x345.jpg" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In this blog I will show you how you can use state machines in your MSP430 projects easily. &lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In this blog I will show you how you can use state machines in your MSP430 projects easily. &lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;We will start with a simple blink example. For this example, we will use the well known Code Composer Studio (CCS) together with integrated YAKINDU Statechart Tools (SCT). As you will see throughout this blog post, both development environments fit together nicely. &amp;nbsp;The full example with installation and setup instructions can be downloaded at the end.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/msp430-microcontroller-programmed-with-state-machines-with-yakindu-state-chart-tools_725x345.jpg?t=1499164433530&amp;amp;width=724&amp;amp;name=msp430-microcontroller-programmed-with-state-machines-with-yakindu-state-chart-tools_725x345.jpg" alt="MSP430 Microcontroller from Texas Instruments, programmed with state machines with YAKINDU Statechart Tools" width="724" title="MSP430 Microcontroller from Texas Instruments, programmed with state machines with YAKINDU Statechart Tools" style="width: 724px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Why MSP430?&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;a href="http://www.ti.com/lsds/ti_de/microcontrollers-16-bit-32-bit/msp/overview.page?utm_source=GOOGLE&amp;amp;utm_medium=cpc&amp;amp;utm_term=msp430&amp;amp;utm_campaign=MCU_MSP_DE_IL_N_E_MSP430&amp;amp;utm_content=cea7b5f4-1bbc-41d9-b56a-3bd013342245"&gt;&lt;span style="font-weight: 400;"&gt;MSP430&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; is a 16-Bit microcontroller from Texas Instruments that is widely used in industry and designed for low power consumption embedded applications. Texas Instruments provides several LaunchPads for different MCUs for a quick start in developing embedded systems. In our example we use the MSP-EXP430G2 LaunchPad. But any LaunchPad with two LEDs is sufficient to run this simple example.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Why State Machines?&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;State machines are a well known concept for modeling reactive, event-driven systems. If the application gets more and more complex over time, a good software design is crucial for readability and reusability of source code.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;There are several approaches to write state machines manually. In C you usually implement them by using a &lt;/span&gt;&lt;a href="/de/modellieren-mit-zustandsautomaten-teil-3-die-gro%C3%9Fe-switch-anweisung"&gt;&lt;span style="font-weight: 400;"&gt;switch/case&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; or a &lt;/span&gt;&lt;a href="/de/modellieren-mit-zustandsautomaten-teil-4-darstellung-als-tabelle"&gt;&lt;span style="font-weight: 400;"&gt;transition table&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;. Writing state machines manually is a good way to understand the underlying concepts. But once you are familiar with them, you will find yourself writing a bunch of boilerplate code &amp;nbsp;which is a very time consuming, inefficient and error prone task. Automatic code generation is a good choice therefore. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;One approach is a &lt;/span&gt;&lt;a href="http://www.ti.com/lit/an/slaa402a/slaa402a.pdf"&gt;&lt;span style="font-weight: 400;"&gt;code generation tool based on Microsoft Excel&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; offered by TI, an open source solution developed for the MSP430. This is a pragmatic way, but if you use state machines often in your development you will miss some more sophisticated tool features like a graphical editor, model validation and simulation. An alternative to the excel based solution is YAKINDU Statechart Tools.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Why YAKINDU Statechart Tools?&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;This is how the simple blinky example could be realized with our Professional Edition: &lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/blinky-example_02.png?t=1499164433530&amp;amp;width=320&amp;amp;name=blinky-example_02.png" alt="blinky-example_02.png" width="320" style="width: 320px;"&gt;
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/blinky-example_02_1.png?t=1499164433530&amp;amp;width=320&amp;amp;name=blinky-example_02_1.png" alt="Blinky example with YAKINDU statechart tools" width="320" style="width: 320px;" title="Blinky example with YAKINDU statechart tools"&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;With YAKINDU Statechart Tools Professional Edition you can import existing header files. This has the advantage that you can directly set the predefined values into the available registers. For example, when the state machine enters the State &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;redOn &lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;the entry action P1OUT |= BIT0 is executed. By setting BIT0 of the P1OUT register &amp;nbsp;the red LED turns on.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;/span&gt;Time dependent events are supported out of the box with a simple implementation of a timing service that is provided with the example. This timing service must only be triggered periodically by any hard- or software timing event, for example the WDT.&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Fully Integrated in your Code Composer Studio&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Tools and Code Composer Studio are both based on Eclipse. Thus, SCT can be installed as a plugin into Code Composer Studio. You can still use all features, which are delivered by CCS - Compiling, uploading and debugging your code. &lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/integrated-in-code-composer-studio.png?t=1499164433530&amp;amp;width=724&amp;amp;name=integrated-in-code-composer-studio.png" alt="Screen YAKINDU statechart tools integrated in code composer studio" width="724" title="Screen YAKINDU statechart tools integrated in code composer studio" style="width: 724px;"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Adding the YAKINDU Statechart Tools as a plugin provides several advantages. You can create new projects or expand existing projects with a state machine. Go and give it a try!&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;How to get it?&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Tool as a plugin can easily be installed by “Install New Software” in your Code Composer Studio. For this, you only need to register up on &lt;a href="https://www.itemis.com/en/yakindu/statechart-tools/"&gt;our website&lt;/a&gt;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&amp;nbsp;and get the download link. A detailed description of how it works will be provided in the example.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=1fffd29a-3aab-4024-b4ab-6ad7061f9154&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Download YAKINDU Statechart Tools and use the example wizard" src="https://no-cache.hubspot.com/cta/default/761475/1fffd29a-3aab-4024-b4ab-6ad7061f9154.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fhow-to-program-a-msp430-with-state-machines-in-5-minutes&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Tue, 11 Apr 2017 15:40:00 GMT</pubDate>
      <author>robin.herrmann@itemis.de (Robin Herrmann)</author>
      <guid>https://blogs.itemis.com/en/how-to-program-a-msp430-with-state-machines-in-5-minutes</guid>
      <dc:date>2017-04-11T15:40:00Z</dc:date>
    </item>
  </channel>
</rss>
